Exercice 1.1 :

Le principe est dâ€™avoir deux clefs, de telle sorte que
â€¢ un message chiffrÃ© avec la premiÃ¨re clef ne peut Ãªtre dÃ©chiffrÃ© quâ€™avec la seconde,
â€¢ un message chiffrÃ© avec la seconde clef ne peut Ãªtre dÃ©chiffrÃ© quâ€™avec la premiÃ¨re.
â–¶ Par convention, lâ€™une de ces clefs est appelÃ©e la clef privÃ©e et lâ€™autre la clef publique


Exercice 1.2 :

P et Q doivent etre Ã©gale a la somme de bits / 2


Exercice 1.4 :

ğ‘’ dois Ãªtre premier avec ğœ‘(ğ‘›) et strictement infÃ©rieur Ã  ğœ‘(ğ‘›), quâ€™on appelle lâ€™exposant de chiffrement.

Exercice 1.6 :

L'exposant de dÃ©chiffrement d (privÃ©) se calcule en fonction des valeurs e et n, voici comment on le calcule :

Inverse de ğ‘’ modulo ğœ‘(ğ‘›) et strictement infÃ©rieur Ã  ğœ‘(ğ‘›), quâ€™on appelle lâ€™exposant de dÃ©chiffrement.

Exercice 2.1 :

(a) Bob doit utiliser la clÃ© publique d'Alice, c'est-Ã -dire ğ´ğ‘. La clÃ© publique est connue de tous, et elle permet de chiffrer un message de maniÃ¨re Ã  ce qu'il ne puisse Ãªtre dÃ©chiffrÃ© que par la clÃ© privÃ©e correspondante, qui est connue uniquement d'Alice.

(b) Alice doit utiliser sa clÃ© privÃ©e, c'est-Ã -dire ğ´ğ‘ . La clÃ© privÃ©e est nÃ©cessaire pour dÃ©chiffrer un message qui a Ã©tÃ© chiffrÃ© avec la clÃ© publique correspondante.

Exercice 2.2 : 

L'opÃ©ration aux quelle consiste chacune des opÃ©rations dÃ©crite Ã  la question prÃ©cÃ©dente sont les suivante :

C = m^e mod n. pour chiffrer le message dans notre exemple cela nous donne B(m) = m^e(public d'Alice) mod n.
m = m^d mod n. pour dÃ©chiffrer le message dans notre exemple cela nous donne m(B) = m^d(privÃ© de Bob) mod n.

Exercice 3.1 :

(a) Bob doit utiliser sa clef privÃ©e ğµğ‘  pour signer un message.

(b) Alice doit utiliser la clef publique ğµğ‘ pour vÃ©rifier l'authenticitÃ© du message qui prÃ©tend Ãªtre signÃ© par Bob.

Exercice 3.2 :

La procÃ©dure de signature numÃ©rique RSA avec un condensÃ© est la suivante :

-> Calcul du condensÃ©

Le premier Ã©tape consiste Ã  calculer un condensÃ© du message Ã  signer. Une fonction de hachage est utilisÃ©e pour gÃ©nÃ©rer un nombre binaire de taille fixe Ã  partir du message. Ce condensÃ© est souvent appelÃ© "empreinte numÃ©rique".

-> Exponentiation du condensÃ©

Le deuxiÃ¨me Ã©tape consiste Ã  exponentier le condensÃ© par la clef privÃ©e du signataire. Cela permet de crÃ©er une signature numÃ©rique qui est unique au message et Ã  la clef privÃ©e.

-> Transmission du message et de la signature

Le signataire transmet ensuite le message et la signature au destinataire.

La forme du message signÃ© est la suivante : 

Message | Signature

(ğ‘š, ğ‘ ) 

Exercice 4.1 :

La mallÃ©abilitÃ© de RSA est un problÃ¨me de sÃ©curitÃ© qui permet d'obtenir un nouveau chiffrÃ© valide Ã  partir d'un chiffrÃ© existant. Cela est possible car la fonction de dÃ©chiffrement RSA est injective, mais pas surjective.

Pour illustrer ce problÃ¨me, supposons que nous avons un message clair m et sa signature numÃ©rique s, calculÃ©e avec la fonction de signature numÃ©rique RSA.

m = 1234567890
s = rsa.sign(m, s_key)

Si nous interceptons le chiffrÃ© c du message m, nous pouvons le modifier en ajoutant ou en supprimant des bits. Cela ne changera pas le message clair original, mais cela changera la signature numÃ©rique.

c = rsa.encrypt(m, e_key)
c += 1

Nous pouvons ensuite utiliser le nouveau chiffrÃ© c pour obtenir une nouvelle signature numÃ©rique s'.

s' = rsa.sign(c, s_key)

La nouvelle signature numÃ©rique s' est valide, car elle est calculÃ©e Ã  partir du mÃªme condensÃ© que la signature originale s.

rsa.verify(c, s', e_key)

Ce problÃ¨me de sÃ©curitÃ© peut Ãªtre utilisÃ© pour produire des attaques par falsification de message. Par exemple, un attaquant pourrait intercepter un message signÃ©, puis le modifier pour ajouter ou supprimer des informations. L'attaquant pourrait ensuite utiliser la nouvelle signature numÃ©rique pour faire croire au destinataire que le message est authentique.

Exercice 4.2 :

Le dÃ©terminisme du chiffrement RSA est un problÃ¨me car il peut Ãªtre utilisÃ© pour mener des attaques par analyse de frÃ©quence.

L'analyse de frÃ©quence est une technique d'attaque qui exploite la distribution des lettres dans une langue naturelle. En effet, certaines lettres sont plus frÃ©quentes que d'autres dans une langue naturelle. Par exemple, la lettre "e" est la lettre la plus frÃ©quente en franÃ§ais.

Si un attaquant intercepte deux messages chiffrÃ©s avec la mÃªme clef, il peut utiliser l'analyse de frÃ©quence pour dÃ©terminer la frÃ©quence des lettres dans les messages clairs. Cela lui permet ensuite de dÃ©chiffrer les messages clairs.
